/*
a)	计算G的转置, G’.
b)	通过计数排序按照L值, 增序排列G’中的点.
c)	在图G’上调用dfs, 主循环中, 使用上述的L增序排列.
d)	对dfs树中的根节点v, 以及每棵dfs树中的非根节点w, 在G’中, 存在v到w的路
	径, 也就是说, 在原图G中, 存在w到v的路径, 所以, L(w) <= L(v).
e)	通过证明L(w) < L(v)不可能出现, 从而证明, 在整棵dfs树中, 对于所有的非根
	节点u, 存在min(u) = v.
	上述过程, 并没有计算根节点v的min值, 因为只是计算了在G’中, 从v出发, 即
	在G中, 到v的点的min值. 解决该问题, 可以修改dfs_visit, 使得在for循环中,
	访问到的u是黑色, 但是v的min值没有被设置时(初始化为uint.MaxValue), 对u
	的min值设置为v(这棵dfs树的root)的L值.
f)	证明:
	如果在R(u)中, 如果存在点w, 满足L(w) < L(v),  那么min(u) =  w != v.
	由于按照L值递增的顺序进行dfs, 所以, w必然在v之前被访问, d[w] < d[v],
	由于v是根, 所以v不可能是w的后代, 因此, f[w] < d[v], 所以
	, d[w] < f[w] < d[v] < f[v]. 又因为, u到w是可达的,  所以,
	d[u] < d[w] < f[w] < d[v], 表明, 在访问v之前, 还访问了u, 而u也是在
	以v为根的dfs树中, 这与v是dfs的根这一事实矛盾.
*/
