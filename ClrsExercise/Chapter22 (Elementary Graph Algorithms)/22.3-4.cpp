/*
 边(u, v)是一条:
 前向边或树边, 当且仅当d[u] < d[v] < f[v] < f[u];
 反向边, 当且仅当d[v] < d[u] < f[u] < f[v];
 交叉边, 当且仅当d[v] < f[v] < d[u] < f[u].

 以上三种情况, 对应于括号定理的三种情况.
 
 =>
 如果(u,v)是树边或者前向边, 那么, 当(u,v)被访问到时, u是灰色, v是白色, 因此,
 d[u] < d[v]. 而且, v是u的后裔, 必然需要当v及其邻接表都被访问过后, 才能完成
 u的访问, 所以f[v] < f[u].
 <=
 由于v在u为灰色时被发现, 所以v必然是u的后裔(深度优先搜索的性质: 在深度优先
 森林中, 顶点v是顶点u的后裔, 当且仅当v是在u为灰色时被发现的).
 如果v是u的后裔, 那么, (u,v)必然是树边或者正向边.

 =>
 如果(u,v)是反向边, 表示当访问到(u,v)边时, v是灰色, 也就是说, v在u之前就被
 访问到, 因此, d[v] < d[u].
 因为(u,v)是反向边, 所以u是v的后裔, 因此, f[u] < f[v].
 <=
 根据d[v] < d[u] < f[u] < f[v], 以及命题1, 可得, (v, u)一定存在, 且是正向
 边或者树边,
 所以, (u,v)是反向边.

 =>
 (u,v)是交叉边, 表示二者互无后裔关系. 所以:
 可在u变为黑色之后再访问到v, 反之亦然.
 有:
 d[u] < f[u] < d[v] < f[v]
 d[v] < f[v] < d[u] < f[u]
 但是, 第一个不等式不可能成立, 因为(u,v)是存在的, 所以不可能访问完u以及u的
 邻接表之后, 仍然未发现v, 所以只有不等式2成立.
 <=
 如果不等式2成立, 表示二者的时间上无交集, 也就互无后裔关系, 因此是交叉边.
 */

