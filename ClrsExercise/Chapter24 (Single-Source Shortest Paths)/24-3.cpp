// 1
// 对不等式两边取log, 得log(i1, i2) + log(i2, i3) + ... + log(ik, il) > log(1) = 0.
// 令xk = log(ik, i_(k+1)), 上式为:
// x1 + x2 + ... + xk > 0 (xk为任意实数).
// 令图G的每条边的权值分别对应x值, 再找G上的路径为正的边.
// 令yk = -xk, 得:
// y1 + y2 + ... yk < 0.
// 将G的边的权值改为y, 添加一个源点y0, 并加入y0至任意的yi(1 ≤ i ≤ k), 权值为0,
// 通过bellmanford方法, 如果存在负权环, 那么, 表示存在这样的一个序列.
// 共n种货币, O(n^2)种组合, 所以G共有n^2条边, n个顶点, 因此, 构造图 + bellmanford
// 共消耗: O(n^3).
// 2
// 通过bellmanford方法, 找到一个经过V-1次迭代后, d值依然会改变的节点u, 通过
// u的π域, 可以找到该路径. cost = O(V) = O(n).
// totalCost = O(n) + O(n^3) = O(n^3).
