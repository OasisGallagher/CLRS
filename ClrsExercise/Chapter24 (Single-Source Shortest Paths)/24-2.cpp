// 1.
// 如果box x在box y之中, 那么, 存在x_π(i) < y_i.
// 如果box y在box z之中, 那么, 存在y_π(i) < z_i.
// 那么, x_π(i) < y_i < z_γ(i).
// 也就是说, 存在一个函数β, 使得x_β(i) < z_i.
// 因此, x在z之中. 因此, box属性满足传递性.
//
// 2.
// 将所有x_i和y_i分别排序.
// 移除比较x_i和y_i, 如果均满足x_i < y_i, 那么, x在y中.
// 否则, x_i >= y_i, 那么, x中≤y_i的元素有i-1个(i从1开始),
// y中≤y_i的元素有i个.
// 即, 无论如何排列x的元素, 都无法满足x_i < y_i可以一一对应.
// 因此, 通过比较排过序的x和y内的元素, 可以判断二者的包含关系.
// O(dlogd) * 2 + d = O(dlogd).
//
// 3.
// 将每个B当做图G的顶点, 加入边e(Bi, Bj), 如果Bi在Bj之中.
// 先将每个Bi, 内部的元素排序, cost = ndlog(d).
// 处理C(n, 2)组间的比较, cost = dn(n-1) / 2.
// 因此, 预处理的cost1 = O(ndlog(d) + dn^2).
// 加入一个顶点, B0, 并连接B0到Bi(1 ≤ i ≤ n), 令权值为0.
// 可以证明该图G, 一定是无环的, 因为问题转变为在dag上求最长路径的问题.
// 将每条路径的权值变为其相反数, 再调用DagShortestPaths.
// 总的效率为:
// cost1 + n^2(共有O(n^2)条边, 且DagShortestPaths为线性的) = O(ndlog(d) + dn^2).
//
