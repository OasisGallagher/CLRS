// code: ./Coins.cs
// 从起点S到终点T, 并吃完所有的金币的最短路径问题.
// ######
// #S@.T#
// #@.@.#
// ######
// @表示金币, .为可行点, #为墙壁.
// 对常规的最短路径问题, 每个顶点p的坐标为(x, y), 对另外一个顶点q, 存在
// 一个函数w, 使得w(p, q) = r(如果r为INF, 表示二者之间没有边相连, 否则表示
// 二者的边的权值为r), 每个节点有一个d值, 表示S到T的最短路径长度.
// 可以通过bellmanford等算法取得从S为起点到任意其他点的最短路径.
//
// 需要吃金币, 就需要让S到T的最短路径必然经过金币点.
// 可以这样考虑该问题:
// 将每一个点当做图中的一个点.
// 为每个点p, 再加一个维度, 为一个bitset, 长度为金币的个数n.
// 可以证明, 转化后的问题与传统最短路径一样, 有最有子结构:
// 即在一条最短路径(S, v1, v2 ... vn, G)上, 任意的vi到vj依然是最优的.
// 这样, 一个节点会分裂为2^n个节点, 那么, 对应的d值表示:
// 当S到(x, y)点, 且吃到的金币数为bitset所标示时(比如3枚金币, 101标示0和2
// 号金币已经吃到)的最短路径.
// 再建立w, 对于w(p, q):
// 如果p和q的位置不相邻, 那么为INF.
// 如果q是金币点, 索引为cq, 且p.bitset不包含cq, 或者, p.bitset == q.bitset,
// 那么, w(p, q) = 1.
// 当relax(u, v)时, 当v.d > u.d + w(u, v)时, u和v的坐标必然相邻
// (否则w(u,v)= INF).
// 当v.bitset == u.bitset, v.d = u.d + w(u, v)
// 当v是金币点, 索引为cv, 且u.bitset不包含cv时, v.d = u.d + w(u, v).
// 综上, 令v.d = u.d + w(u, v)即可.
//
