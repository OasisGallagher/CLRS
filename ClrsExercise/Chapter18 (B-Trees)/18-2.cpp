/*
 (a)
 维护每个内节点的高度(叶子节点的高度为0, 高度为从该点到叶子的简单路径的路
 径长度).
 在INSERT时, 如果根节点已满, 那么需要建立新的节点, 并使树的高度+1.
 此时新根的高度 = 旧根的高度+1.
 分裂出来的新节点的高度与原节点的高度一致.
 在DELETE时, 情况2c和3b时, 如果根节点的唯一的关键字被孩子合并, 那么会减少
 树的总高度. 但是其它节点的新高度不会变, 只需要保证分裂出来的新节点的高度
 与原节点一致即可.
 SEARCH为const操作, 不会有影响.
 上述操作在SPLIT中, 以O(1)完成, 因此不会影响B树操作的渐进运行时间.
 __________________________________________________________________________
 (b)
 参照13-2.红黑树保证每个节点到任一叶子节点的黑高度相等.B树保证每个叶子节点
 具有相同的高度.
 那么, 对于树T'和T'', 
 如果h[T'] > h[T'']. 在T'中找到最右侧的节点t, 满足以t为根的子树的高度 
 = h[T'']. 向t中加入关键字x, 再在x右侧的子节点域, 加入T''.
 
 如果h[T'] < h[T''], 在T''中找到最左侧的节点t, 满足以t为根的子树的高度
 = h[T']. 向t的第0个位置插入关键字(其它关键字后移), 再在0#加入子节点域(
 其它子节点域后移).

 为防止t节点已满, 可以调用类似INSERT的方法: 如果根是满的, 那么分裂根, 并
 产生新根, 再递归的向新根插入; 否则, 直接向根插入(INSERT_NONFULL).
 INSERT_NONFULL需要有细微的简化:
 (1)
 如果当前需要处理的节点的高度 == 另一棵树的高度, 那么按照一开始的方法插入
 即可. 如果遇到叶子节点, 表示另一棵树的高度为0, 也继续直接插入即可.
 (2)
 查找第一个不小于x的关键字的关键字的过 程可以省去, 而是直接取用最后一个关
 键字的位置.
 在继续向下查找时, 与常规查找相同, 如果子节点已满, 先分裂它, 再进行
 INSERT_NONFULL.

 整体需要向下遍历h = abs(h[T'] = h[T'']), SPLIT操作为O(t) = O(2), 所以最坏
 代价为O(h + 1).

 如果h[T'] == h[T''], 分配一个新根, 关键字为x, 左孩子为T', 右孩子为T''即可.
 __________________________________________________________________________
 (c)
 如图18-2.png, 2-3-4树, 根节点是满的.
 在这棵树中搜索一个关键字p, 那么, 必然从根开始, 经过一系列的子节点, 最终到
 达关键字p, 这个路径的长度设为L(L <= h).
 如图所示, 
 如果p不在当前节点内, 而且需要继续在它的ci孩子搜索, 那么, 对于第j层:
 i=1: kj = nil, Tj = nil.
 i=2: kj = k1, Tj为n=0, 只有一个子节点指针c1的根.
 i=3, kj = k2, Tj为n=1, 子节点指针包含c1和c2的根.
 i=4, kj = k3, Tj为n=2, 子节点指针包含c1, c2和c3的根.
 注意, 这些根所形成的子树, 一定是不相交的. 因为所形成的子树, 不包含下一级
 所搜索的子树的任何一个节点.
 树的高度是递减的, 递减的数量不定(因为可能遇到上面所述的i = 1的情况).
 如果p在当前节点内, 与kx相等. 那么, kj = kx, Tj为n=x-1, 子节点指针包括
 c[0, x]的根.
 分割路径所形成的右侧, 与上面的对称.
 __________________________________________________________________________
 (d)
 实际的分裂操作, 比如以p分割, 那么先找到一条到p的路径, 然后按照(c)中的方法,
 将树T按照该路径分割.
 分割出来的两侧的T1, K1和T2, K2的集合, 就是两棵新的树.
 下面来考虑将左侧的集合合并成一棵树, 右侧与此对称.
 由于T1中的任何两个相邻元素, T1_i和T1_(i-1), 之中的任意两个关键字x和y, 必有:
 x < K1_i < y.
 那么, 可以调用JOIN(T1_i, K1_i, T1_(i-1))
 因此, 为了合并集合1中的所有树和关键字:
 #
 remove all nil in set T1 and K1.
 for i = m to 1:
     JOIN(T1_i, K1_i, T1_(i-1))

 JOIN的代价为O(1 + |h(T'_(i-1) - h(T'_i)|)
 总的代价为:
 cost = sum(i = m to 1)(O(1 + |h(T'_(i-1)) - h(T'_i)|))
      = m + sum(i = 1 to m)(|h(T'_(i-1)) - h(T'_i)|)
	  为简便, 将h(T'_i)写为H(i).
	  = m + O(H(m-1)-H(m)+H(m-2)-H(m-1) + ... + H(0)-H(1))
	  = m + H(0) - H(m)	#telescope.
	  与树的高度线性相关(O(log_t((n+1)/2)).
 
 T1, K1合并成一棵树, T2, K2合并成一棵树, 即为所求.
 */

