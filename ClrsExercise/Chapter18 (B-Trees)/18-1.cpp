/*
(a) 采用第一种方法, 每次PUSH都会引起一次磁盘读取以及一次磁盘写入; 每次
    POP都会因此一次磁盘读取.
	假设有i个push, n-i个POP, 那么总的磁盘读取数为
	i*2 + (n-i) = n + i = O(n)
	每次读写磁盘的时间为m, 那么, 总的CPU时间为O(mn).
(b)
	将一页存入主存, 每个页上有m个字.
    那么, 在m次PUSH之后, 才会引发一次磁盘写入, 以及一次读取.
	所以n次PUSH所需的磁盘存取次数为2 * ceil(n / m) = 2((n - 1) / m + 1).
	每次磁盘存取的代价为m, 所以, 总的CPU时间为2(n - 1 + m).
(c)
	进行n次栈操作, 由于主存中达到m个字, 就会引发一次写入, 一次读取,
	最坏情况为, 当主存中有m-1个字时, 继续PUSH, 引发写入和读取, 再进行POP,
	引发读取, 依次循环.
	那么, 总的存取次数为, 先进行m - 1次PUSH, 为O(1). 再进行总数为
	c = n - m + 1次交替的PUSH和POP.
	共1 + (c-1) / 2次PUSH, 以及c/2次POP.
	总次数为:
	2 + c - 1 + c / 2 = 1 + 3c / 2 = 1 + 3(n - m + 1) / 2
	次存取操作.
	CPU时间为1 + 3m(n-m+1) / 2.
(d)
	利用记账方法进行平摊分析.
	(1) 计算存取次数.
	对每次PUSH, 收取代价为2/m元的费用, 其中1/m元用来支付PUSH, 另外的1/m元
	存起来.
	那么, 在任意时刻现存的金额为c/m, c为当前栈内的元素个数.可见, 在任意时
	刻, 存款总是非负的.
	当栈满时, 由于页面大小为2m, 那么, 此时所剩存款为2m/m = 2.
	正好用来支付一次写入, 一次读取.
	因此, 平摊磁盘读取次数为O(1/m).
	(2) 计算平摊CPU时间.
	对每次PUSH, 收取3元的代价, 其中1元用来支付PUSH, 另外的2元存储起来.
	那么任意时刻, 现存的金额为2c, c为当前栈内的元素个数. 可见, 在任意时刻,
	存款总是非负的.
	当栈满时, 所剩存款为2*2m = 4m. 这些存款, 2m用来写入2m个栈中的元素, 2m
	用来读取2m个元素到主存, 存款清0, 此时栈内的元素个数也为0.
	因此, 平摊的CPU时间为3 = O(1).
*/

