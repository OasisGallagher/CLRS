/*
 18.1-1
 如果t=1, 那么一个节点含有[0, 1]个key.
 考虑向树中插入A, 得到:
 c | A | c
 再次插入B时, 由于此时root已满, 需要重新构建一个root, 并把旧的root作为新
 root的第一个孩子, 进行split.
 注意到, split之后, 旧的root的关键字数为0, 而新root的关键字数为1.
 此时无法在新root上执行INSERT_NONFULL, 因为此时的新root依然是满的.
 所以, t不能是1.
 18.1-2
 t = 3.
 18.1-3
 omitted
 18.1-4
 当一个节点满时, 可以存储2t-1个关键字.
 每个满节点, 有2t个子女.
 因此, 总的节点数为等比数列和:
 1 + 2t + (2t)^2 + (2t)^3 + ... (2t)^n = (1-(2t)^n) / (1-2t) -> (formula 1)
 因此, 总的关键字数为
 (2t-1)* (formula 1) = 4t^n-1
 18.1-5
 因为红黑树中的黑节点, 最多只能有两个红色子节点(已经并入其它节点应该算作
 是无效的颜色), 并入之后, 之前的红黑树会成为t=2的B树, 即2-3-4树.
 */
