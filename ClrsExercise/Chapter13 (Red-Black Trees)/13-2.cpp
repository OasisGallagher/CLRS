// (a) 如果维护一个树的黑高度, 那么需要在insert_fixup和delete_fixup时
//     修改这个高度.
//     拿插入来说:
//     如果插入节点的叔父的颜色是红色, 那么将叔父和父亲的颜色置黑,
//     并将祖父的颜色置红, 那么祖父为根的红黑树的黑高度-1+1, 没变.
//     如果叔父是红色, 且插入节点是右孩子, 那么经过左旋, 再右旋, 
//     可以分析出, 也不会改变黑高度.
//     改变树的黑高度的操作只有置root为黑的操作.
//     对于删除, 只有当sibling是黑色, 而且它拥有两个黑色的孩子, 那么
//     将sibling置为红色来减少黑高度.
//     如果root之前的颜色是红色, 那么会使黑高度+1.
//	   如果需要重新计算树的BH, 可以沿根, 按照一条路径下降至叶子.
//	   统计遇到的黑节点个数(不包括根但是包括叶子(NIL)).
// (b) T1为h1, T2的为h2, 而且h1 > h2. 找到T1中, BH = h2的节点
//	   中含最大的关键字的节点y.
//     因为T1的BH大于T2的, 所以, 从T1的根的右孩子开始, 一直向右孩子
//     迭代, 在到达叶子节点之前, 一定.所以可以遇到
//     h1 - h2个黑节点. 即:
//     y = root;
//     for(int i = 0; i < (h1 - h2); ) {
//         y = y->r_child;
//		   if(color[y] == black)
//		       ++i;
//     }
//     最坏情况下, 需要遍历从跟到叶子的所有右孩子, 所以效率为O(lg(n)).
// (c) 注意: 这里的Ty中的y, 指的是(b)中找到的y节点.
//     这个节点为黑色, 而且以这个节点为根的子树的黑高度与T2相等.
//     那么, 创建x, 使其左孩子指向y, 右孩子T2的根.
//     将x置为红色, 从而使x子树的BH与原Ty的BH相同.
//     所以红黑树的性质1(只有红黑两种颜色的节点), 性质3(叶子为黑),
//     性质5(从任意节点到叶子的简单路径上, 黑节点数目相同)都得以满足.
// (d) 将x置为红色后, 可能其parent也为红色, 或者根为红色, 使用insert fixup
//	   流程即可在log(n)时间内修复.
// (e) 综上所述, 整个操作可以在log(n)时间内修复.
//
//
