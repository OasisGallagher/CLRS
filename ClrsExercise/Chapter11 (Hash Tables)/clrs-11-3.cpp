//  二次探查:
//  h(k, i) = (h2(k) + c1 * i + c2 * i * i)
//  c1 = 1 / 2, c2 = 1 / 2.
//  算法需要能遍历到m个槽位中的每一个. 那么, 对于p, q(p != q),
//  当j < m时, h(k, p) != h(k, q). 
//  这样才能保证, 每个槽位都能被探查到,
//  当j == m时, 探查结束, 所有的槽位都被探查到.
//  假设h(k, p) == h(k, q), 那么p(p+1) / 2 === q(q+1) / 2 (mod m). 即:
//		(p^2 + p - q^2 - q) / 2 === 0 (mod m)
//  =>	(p - q)(p + q + 1) === 0 (mod 2m)	这里把2放到了mod这里.
//	已知m = 2^k, 即:
//	=>	(p - q)(p + q + 1) = x * 2 * 2^k = x * 2^(k+1).
//	再来考虑左边的因式的奇偶性.
//  p-q和p+q+1必然是奇偶互异的. 也就是说, 对于2^(k+1)的因子(即2m), 必然由
//  p-q或者p+q+1一个因式提供.
//  即:
//  2^k | p-q		(1)
//  2^k | p+q+1		(2)
//  必然有且仅有一个成立.
//  先考虑(1), 必然小于m, 所以(1)不可能成立.
//  再考虑(2), p+q必然 <= (m-1 + m-2), 所以(2) <= m + m - 2.
//  也是小于2m, 因此, h(k, p) == h(k, q)是假命题, 因此, h(k, p) != h(k, q).
//
