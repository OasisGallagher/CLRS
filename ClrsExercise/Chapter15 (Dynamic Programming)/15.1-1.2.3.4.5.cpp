// < 15.1-1 >
PRINT_STATIONS(l, line_number, n, j)
	if j >= 2
		next_line = l[line_number][j]
		PRINT_STATIONS(l, next_line, n, j - 1)
	print "line " line_number "station " j
// 
PRINT_STATIONS(l, line_number, n, n);
// </ 15.1-1>

// < 15.1-2>
r(1, j) = r(2, j) = r(1, j + 1) + r(2, j + 1);
let r(i, j) = 2^(n - j);
left:
	r(1, j) = 2^(n - j)
right:
	r(1, j + 1) + r(2, j + 1) = 2^(n - j - 1) * 2 = 2(n - j)
so left == right.
// </ 15.1-2>

// < 15.1-3 >
// 等比公式求和即可.
// </ 15-1-3 >

// < 15.1-4 >
// 可以不存储l结构, 在f结构中另外存两个值, 即加上最后的x后的两个最优值.
// 然后回溯, 通过计算结果比较, 确定这个最优值是经由哪条路径过来的, 就可以
// 确定路线.
// </ 15.1-4 >
//

// < 15.1-5 >
// l结构表示的是, 上一步是哪个线路, 如果l[1, j] = 2, 表示:
// f[2, j - 1] + t[2, j - 1] + a[1, j] <= f[1, j - 1] + a[1, j]
// l[2, j] = 1表示:
// f[1, j - 1] + t[1, j - 1] + a[2, j] <= f[2, j - 1] + a[2, j]
// 简言之, 就是换线会得到更短的时间. 参考程序中的比较, 只有在else分支,
// 也就是"等号"不成立时才会选择换线, 因此上述的等号是不成立的. 所以, 上述
// 两个不等式应该是:
// f[2, j - 1] + t[2, j - 1] + a[1, j] < f[1, j - 1] + a[1, j]
// f[1, j - 1] + t[1, j - 1] + a[2, j] < f[2, j - 1] + a[2, j]
// 两个不等式相加并消去相同项:
// t[2, j - 1] + t[1, j - 1] < 0
// 已知t值非负, 所以不等式不成立, 因此题目中的说法是错误的.
// </ 15.1-5 >
//
