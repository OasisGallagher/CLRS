/* !
 * 这里存储的秩, 是相对于以该节点为根的子树而言的, 亦即, 以该点为根的
 * 左子树的size + 1(自身).
 * 如果存储的是在整棵树的秩, 那么, 插入一个最小值时, 树中每个节点的秩
 * 都会发生变化.
 * !
 * 一个节点B的秩即为左子树的size + 1.
 * 当插入时, 如果新节点的值小于当前遍历的节点, 那么需要向左子树查找,
 * 此时, 把当前遍历节点的秩 +1, 之后在查找中, 凡是遇到需要查找当前遍历
 * 节点的左节点时, 都将该节点的秩 +1.
 * 在左旋时, x的秩不变, y的秩 += x的秩.
 * 右旋时, x的秩不变, y的秩 -= x的秩.
 * 删除时与插入类似, 如果删除的节点或者所在子树是左孩子, 那么节点的
 * 秩 -1.
 * 比如, 假设y是要被删除的节点:
 * for(; y != root; y = PARENT[y])
 *     if(LEFT[PARENT[y]] == y):
 *	       --RANK[PARENT[y]]
 */

