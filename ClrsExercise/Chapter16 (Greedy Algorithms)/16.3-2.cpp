/*
 * a: 1111
 * b: 1110
 * c: 110
 * d: 10
 * e: 1
 * 第n个斐波那契数为f(n), 而定义s[i]为:
 * s[1] = f[1]
 * s[2] = s[1] + f[2].
 * ...
 * s[n] = s[n-1] + f[n].
 * 可见, 在计算出s[i]之后, 优先队列有f(i+1 to n)和s[i].
 * 如果下次取得的最小频数为s[i]和f[i+1], 那么, 必然有s[i] <= f[i+2].
 * 否则, f[i+1]和f[i+2]就会使下两个频数最小的数.
 * 计算:
 * f[i+2] - s[i]
 *     = f[i+2] - f[i] - f[i-1] - ... - f[2] - f[1]
 *     = f[i+1] - f[i-1] - ... f[2] - f[1]
 *     = f[i] - f[i-2] - ... f[2] - f[1]
 *     = f[3] - f[1] = 2 - 1 = 1 > 0
 * 因此, 可以推广到第n个斐波那契数.
 * 对于n个斐波那契数:
 * 第一个数的编码为 1...1(n个1).
 * 第k个数的编码为: 1...1(n-k个1) append 0
 */

