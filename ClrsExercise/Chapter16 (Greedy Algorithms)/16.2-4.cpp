/*
 n为汽车的油箱容量.
 共有s'的加油站.
 加入两个虚拟加油站, 0和s'+1, 0表示司机的起点, s'+1表示司机的目的地.
 s = s' + 2.
 假设加油站的编号分别为1 to s, d(i)表示从第i-1加油站到i加油站的路程.
 d(0) = 0.
 c(i, w)表示司机从i加油站出发, 剩余w体积的油, 到达目的地需要加油的最小次数.
 原问题转化为:
 minimize c(0, n).
		   { INF	w < 0
 c(i, w) = | 0		i = n+1
		   { min(1+c(i+1, n-d[i+1]), c(i+1, w-d[i+1])) otherwise.

 在站点i, 如果在该站点加油, 那么, 之后的油量为n, 到达下个站点的油量为:
     n - d[i + 1].
 总的加油次数为:
     1 + c(i + 1, n - d[w + 1])
 如果在站点i不加油, 那么, 油量w不变, 到达下一个站点油量为:
     w - d[i + 1].
 总的加油次数为:
     c(i + 1, w - d[i + 1]).
 两者的最小值, 即为从i到达终点的最少加油次数.

 如果到达i时, 油量为负值, 那么之前的方案是不可行的, 因此返回INF.
 如果到达目的地, 且剩余油量非负, 那么之后不需要再继续行驶, 返回0.

 动态规划的做法, 效率是O(n*s).

 这个问题存在贪心策略的解法. 即: 汽车在无法行驶到下一个站点时, 才选择加油.
 假设加油的站点为t1, t2, ... tn, 如果机车即使在t1处不加油, 依然可以到达t',
 但是从t'无法到达下一站点, 那么可以选择在t'处加油.
 如果t'在t2之前, 那么, t'必然是属于上述方案的, 因为依然可以选择在t2加油, 
 甚至还会减少之后的加油次数.
 如果t' = t2, 或者任一上述方案中t1之后的加油站, 那么, 站点数减少了至少1,
 更优化了上述方案.
 如果t'在t2之后, 且不是上述方案中的站点, 在t'之前的最近上述方案的站点为i,
 之后的最近站点为j, 那么从t'一定可以到达j站点, 因为:
 dist(i, j) > dist(t', j), t'是i和j之间的站点.
 所以, t'一定存在于最优解中. 效率为O(s).
 len = 0
 count = 0
 # add d[s+1] = distance between the last station and the destination.
 for i = 1 to s + 1
     if len + d[i] <= n
	     len += d[i]
	 else
	     print ":station ", i
		 ++count
		 len = 0

*/
