/*
 按照二进制时的方式, 将所有节点按照f值, 构造小根堆.
 从堆中取出f值最小的3个节点(3次pop_heap), 再分配一个新节点, w, 使得
 f[w]=f[x]+f[y]+f[z], 将w进堆.
 重复该过程, 当堆中不足三个节点时, 结束.
 对于二进制来说, 节点数目为n, 每次堆中减少两个节点, 但是会加入一个节点,
 所以, 最终得到的二叉树一定是满二叉树.
 然而, 对于三进制, 如果节点数目为奇数, 即2k+1, 那么, 第一次从堆中取出三个
 节点, 加入一个节点, 剩余2k-1个, 第i次过后为2k-2i+1个节点, 当i=k-1时, 
 2k-2i+1=3, 再构造一次即可使堆中只留一个节点, 作为整棵树的根.
 证明过程可以参考二叉Huffman树的证明.
 如果节点数目为偶数, 2k, 那么, 第i次过后剩余的节点为2k-2i, 最终会遇到堆中
 有两个节点, 继续过程, 使得根节点只有两个孩子, 总的树不是满三叉树的情况.
 这样不能证明三个最低f值的节点为兄弟, 因为其中一个节点可能作为根的一个孩子,
 此时的总的长度可能会更短.
 此时, 先取两个f值最低的x和y, 产生新的节点z, f[z]=f[x]+f[y], 将x,y移出
 堆, 将z加入堆. 此时还剩下2k-1个节点, 再按照奇数节点的方式, 进行构造.
 用引理16.2的中替换的方式可以证明, 最低f值的两个节点必然是兄弟节点.
 且, 去掉x,y加入z之后的字符集, 产生的三叉树是最优的.
 设C={ all characters }, C'=C - {x, y} + {z}, C'上可以构造出一棵最优的前缀
 树T'.
 向T'中加入x和y, 作为z节点的子节点, 得到的T也是最优的.
 通过反证法, 如果在T'上, 加入x和y, 不是z的子节点, 而是另一个节点k的子节点(
 已经证明, x和y必然是兄弟节点, 而且编码长度相同, 所以这个k是存在的, 
 且f[x]=f[y])得到树U优于T', 那么,移除x和y之后, 得到U'
 # U和T表示含有x和y的树; U'和T'表示不含x和y的树.
 F[x]为f[x]*deep[x].
 cost(U')=cost(U)-F[x]-F[y] < cost(T)-F[x]-F[y] = cost(T')
 这与T'是C'上的最有前缀树的假设矛盾.
 */
